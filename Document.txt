Primer de tot, tenim el Singleton motoret on hi ha tota la lògica del joc en si. Hi ha un bucle que només para quan se surt del joc. En aquest bucle primer de tot calculem el deltaTime agafant el temps actual i el temps anterior dividit entre 1000. Seguidament, recorrem la llista de GameObjects que té i fem l’update de cada GameObject. Després d’això cridem al Dispose de cada GameObject i els traiem de la llista utilitzant una temporal i a continuació activem el Start de cada GameObject i els tornem a afegir a la llista. Per últim, hem fet un sistema de FPS que l’hem calculat fent un while el qual espera 1 mil·lisegon, agafa el temps actual i mentre els mil·lisegons per frame sigui més grans que el temps actual menys el temps d’inici de frame. D’aquesta manera tenim un sistema de FPS que podem limitar o augmentar i que es mostra per pantalla.

Tenim fet un sistema GameObject-Component segons el qual només hi ha un GameObjects amb components (transform, render i un component propi de moviment). El funcionament d’aquest paradigma és el següent: tenim una classe abstracta GameObject d’on estén la classe ObjecteRectangle, que fa de gameobject sense components (com un gameobject buit a Unity). Aquest gameobject buit li hem afegit els tres components que hem creat, a la seva funció start, a la llista de components “_Components”. Aquesta llista de components la parsegem tant a l’update com al render del gameobject i actualitzem les seves dades. 
Els components, al seu torn, estenen d’una classe abstracta anomenada “Component” que té la informació bàsica d’aquests, com la referència al GameObject a la qual pertanyen, les funcions virtuals de render i update (per no obligar a tots els fills que estenen aquesta classe a crear-les) i el nom del component mateix.
Els components que hem creat són: 
	- Transform: emmagatzema la posició del gameobject en el món.
	- Render: renderitza la forma del gameobject al món amb les característiques que es passen al constructor per primera vegada.
	- Moviment (Comportament_Moviment): mou el gameobject segons les tecles que es pressionen al teclat (WASD).

A part d’això, hem creat un sistema de Pool i Spawner que funciona de la següent manera: tenim una interfície IpoolableFactory<T> i una classe GameObjectFactory que l’implementa. Aquesta classe implementa els mètodes d’activar, crear, desactivar i eliminar un GameObject. Després, la Pool té una referència a la interfície IPoolableFactory amb la qual segons un número n que li passem per paràmetre, crea n elements els quals els emmagatzemem a una llista. Tot això de manera genèrica. Seguidament, al mètode GetElement recorrem la llista d’elements de la Pool i si l’element està disponible, l’activem i fem que no estigui disponible per tal que passi al següent element sí utilitzable. Si pel que sigui no hi ha més elements disponibles, agafem el primer de la llista, l’activem i el posem al final d'aquesta.

Finalment, tenim un GameObject Spawner que té un component que el que fa és spawnejar GameObjects segons el temps que li passem per paràmetre. Per a fer això sumem el temps passat al deltatime i si és més gran o igual agafem un element de la Pool i restem a aquest temps n on n és el temps que l’usuari desitja.